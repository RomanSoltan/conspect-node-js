/* ======================================================================================================================
Модуль fs
====================================================================================================================== */

// Як ви вже знаєте, важливою відмінністю Node.js від браузера є можливість
// роботи із файлами. Для цього у ній наявний спеціальний модуль fs, який
// дає нам можливості працювати із файлами та папками.

// Для роботи із файлами нам також стане в пригоді модуль path, який ми
// розбирали перед цим.

// Перед тим, як роздивитись деякі приклади роботи з модулем fs, треба
// розглянути декілька загальних принципів у бібліотеках Node.js.

// В багатьох модулях кожна з функцій представлена у вигляді 3 різновидів —
// синхронна функція, асинхронна з колбеком або асинхронна на промісах
// (але є і виключення, наприклад, вже розглянутий нами модуль path).

// В чому між ними різниця і коли кожну з них використовувати?

// ================================

// Синхронна функція. Зазвичай, такі методи містять допис sync в назві метода

// import fs from 'node:fs';

// const fileContent = fs.readFileSync('path_to_file');

// Ми вже з вами розібрали принципи роботи JS в Node.js й ви знаєте, що
// виконання певних операцій синхронно здатне різко знизити швидкодію.

// Запущений процес не зможе обробляти інші вхідні дані, поки він буде
// заблокований. Тому уникайте використання цього варіанту. Але є певні
// випадки, коли така імплементація може стати в пригоді. Наприклад,
// якщо ми робимо якусь дію разово (наприклад, зчитуємо конфіги перед запуском додатка).

// ===========================================

// Асинхронна з колбеком

// import fs from 'node:fs';

// fs.readFile('path_to_file', (err, fileContent) => {
//   /* ваш код */
// });

// На відміну від попереднього варіанту, така функція не буде блокуючою
// і швидкодію додатка знижувати не буде.

// Логіку по подальшій роботі з цією функцією треба писати в колбеці.
// Методи в Node.js мають контракт error first - callback last. Тобто,
// колбек завжди іде останнім аргументом у функціях, а в самому колбеці
// першим аргументом прокидується помилка.

// Перевагою такого підходу є найбільша швидкодія. Цей варіант буде
// працювати в декілька разів швидше, ніж варіант із промісами (дивіться нижче).

// Мінусом же є те, що називається callback hell. Тобто, якщо у вас буде
// багато вкладених колбеків, то різко впаде читабельність коду:

// import fs from 'node:fs';

// fs.readFile('path_to_file', (err, fileContet) => {
//   someOtherFunctionWithCallback(fileContet, (err, data) => {
//     anotherFunctionWithCallback(data, () => {...})
//   });
// });

// Чим більше у вас буде такої послідовної логіки, тим більше буде рости ця “ялинка”.

// Загалом, краще пожертвувати швидкодією (в розумних межах) заради кращої
// читабельності коду. Наприклад, цикл for буде швидший, ніж методи ітерації
// по масиву (наприклад, map), але останній є більш лаконічним і зручним,
// тому переважно розробники виберуть його. Причиною використати саме такий
// варіант може бути або виражена проблема зі швидкодією у вашому додатку,
// або при написанні бібліотек і системного коду, мета яких якраз і є дбати
// про продуктивність.

// ==========================================

// Асинхронна з промісами

// import fs from 'node:fs/promises';

// const fileContent = await fs.readFile('path_to_file');

// Зверніть увагу, що імпорт тепер також має promises у шляху. Цей варіант
// використовується найбільш часто в написанні продуктового коду, оскільки
// він дає читабельність на рівні синхронного коду, але не є блокуючим.

/* ======================================================================================================================
Buffers
====================================================================================================================== */

// Перед тим, як продовжувати розмову про модуль fs, нам варто трохи поговорити про
// таке поняття як Buffer. Ви будете часто зіштовхуватися з ним при роботі з файлами,
// але до цього ви не зустрічалися із чимось подібним.

// Напевно, ви чули такі поняття, як біти, байти та інші терміни, похідні від них.
// Біт — це 1 або 0. Ось просто так і є. Це виражене у двійковій системі “так” або “ні”.
// Байт — це набір із 8 бітів. Загалом у двійковій системі це 256 можливих комбінацій 0 та 1.

// Розуміючи це, ми тепер можемо сказати, що Buffer — це такий собі масив байтів (array of bytes).

// Як ми його можемо отримати? Наприклад, ми можемо прочитати якийсь файл:

// import fs from 'node:fs/promises';

// const buffer = await fs.readFile('hello.txt');
// // припустимо, що в файлі hello.txt був текст Hello World!

// console.log(buffer);
// ///<Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64 21>

// Подивімося на кількість чисел, що йдуть після слова Buffer
// (а це саме і є цифрами, щоправда, у шістнадцятковій системі числення).
// Ви вже зустрічалися із такими цифрами, наприклад, коли працювали із
// hex-записом кольорів у CSS). Бачимо, що їх кількість відповідає
// кількості букв (не варто забувати про пробіл, він також рахується).
// Також розмір кожного елементу буфера складає 1 байт.

// Тобто, в цьому випадку кожне число відповідає за одну букву, а для того,
// щоб закодувати 1 букву, потрібен 1 байт. Щоб дізнатися, яку саме, нам
// треба скористатися кодуванням.

// ----------------------------------

// Що таке кодування і навіщо воно потрібно?

// Насправді будь-який файл складається із байтів. Ви можете в цьому
// переконатися, якщо спробуєте прочитати за допомогою метода readFile
// якусь картинку. На перший погляд, текстовий файл чи картинка в такому
// вигляді будуть не дуже відрізнятися. І саме кодування може допомогти
// нам розрізнити, чи є це звичайний текст, чи картинка, чи може ще
// якийсь різновид контенту.

// Для кодування тексту найпоширенішим форматом є UTF-8. Ви можете
// переконатися, що кожна цифра відповідає символу із фрази “Hello World!” за цим посиланням.

// Для того, щоб вказати, що цифра є саме шістнадцятковою, зазвичай також
// додають префікс 0х (48 може означати й звичне нам число 48, але запис
// 0х48 дає чітко зрозуміти, що це саме число в шістнадцятковій системі).

// Або щоб привести буфер до рядка, ми можемо викликати у нього метод toString(),
// вказавши у дужках кодування:

// import fs from 'node:fs/promises';

// const buffer = await fs.readFile('hello.txt');
// // припустимо, що в файлі hello.txt був текст Hello World!

// console.log(buffer.toString('utf-8'));
// /// Hello World!

// Ви будете мати змогу познайомитися із буферами ближче під час виконання
// домашнього завдання, а також вони зможуть стати вам в пригоді в розділі,
// де ми будемо вивчати завантаження файлів.

/* ======================================================================================================================
Основні методи модуля fs
====================================================================================================================== */

// Модуль fs дає можливості для роботи з файловою системою, що є важливою
// складовою розробки на Node.js. Розгляньмо деякі з основних методів цього модуля.

// [fs.readFile(path [, options])](<https://nodejs.org/api/fs.html#fspromisesreadfilepath-options>)- читання файлу

// Аргументи:

// 1. path (string): шлях до файлу, який потрібно прочитати.
// 2. options (об'єкт) (опціонально): параметри, що визначають
// режим читання. Може бути вказано кодування файлу або інші параметри.

// Результати:

// 1. Promise: повертається об'єкт Promise, який буде вирішено або
// відхилено після завершення операції читання файлу.
// - Вирішено з вмістом файлу у випадку успішного читання.
// - Відхилено з об'єктом помилки у випадку невдачі операції читання.

// import fs from 'node:fs/promises';

// (async () => {
//   try {
//     const data = await fs.readFile('file.txt', 'utf-8');
//     console.log('Вміст файлу: ', data);
//   } catch (err) {
//     console.error('Помилка читання файлу: ', err);
//   }
// })();

// --------------------------------------------------

// [fs.writeFile(file, data [, options])](<https://nodejs.org/api/fs.html#fspromiseswritefilefile-data-options>)- запис файлу

// Цей метод використовується для асинхронного запису даних у файл.

// Аргументи:

// 1. file (string): назва файлу або шлях до файлу,
// в який потрібно записати дані.
// 2. data (string або Buffer): дані, які потрібно
// записати у файл. Може бути представлено рядком або об'єктом Buffer.
// 3. options (string або об'єкт) (опціонально): параметри,
// що визначають режим запису. Наприклад, кодування для текстових файлів або прапорці режиму запису.

// Результати:

// 1. Promise: повертається об'єкт Promise, який буде вирішено або
// відхилено після завершення операції запису в файл.
// Вирішено без аргументів, якщо операція запису пройшла успішно.
// Відхилено з об'єктом помилки у випадку невдачі операції запису.

// import fs from 'node:fs/promises';

// // Записуємо дані у файл 'output.txt'

// (async () => {
//   const data = 'Це дані, які ми записуємо у файл.';
//   try {
//     await fs.writeFile('output.txt', data, 'utf8');
//     console.log('Дані успішно записані у файл.');
//   } catch (err) {
//     console.error('Помилка запису у файл:', err);
//   }
// })();

// ------------------------------------------------

// [fs.appendFile(path, data[, options])];
// (<https://nodejs.org/api/fs.html#fspromisesappendfilepath-data-options>)додавання у файл

// Цей метод використовується для асинхронного додавання даних у кінець файлу.

// Аргументи:

// 1. path (string): шлях до файлу, в який потрібно додати дані.
// 2. data (string або Buffer): дані, які потрібно додати до файлу.
// Може бути представлено рядком або об'єктом Buffer.
// 3. options (string або об'єкт) (опціонально): параметри, що
// визначають режим додавання. Наприклад, кодування для текстових
// файлів або прапорці режиму додавання.

// Результати:

// 1. Promise: повертається об'єкт Promise, який буде вирішено або
// відхилено після завершення операції додавання даних до файлу.
// - Вирішено без аргументів, якщо операція додавання даних пройшла успішно.
// - Відхилено з об'єктом помилки у випадку невдачі операції додавання даних.

// import fs from 'node:fs/promises';

// // Додаємо дані до файлу 'output.txt'

// (async () => {
//   const data = 'Це дані, які ми додаємо до файлу.';
//   try {
//     await fs.appendFile('output.txt', data, 'utf8');
//     console.log('Дані успішно додані до файлу.');
//   } catch (err) {
//     console.error('Помилка додавання даних до файлу:', err);
//   }
// })();

// ----------------------------

// [fs.rename(oldPath, newPath)](<https://nodejs.org/api/fs.html#fspromisesrenameoldpath-newpath>)- перейменування файлу.

// Цей метод використовується для асинхронного перейменування або переміщення файлу чи каталогу.

// Аргументи:

// 1. oldPath (string): поточний шлях до файлу або каталогу,
// який потрібно перейменувати або перемістити.
// 2. newPath (string): новий шлях до файлу або каталогу,
// куди потрібно перейменувати або перемістити файл чи каталог

// Результати:

// 1. Promise: повертається об'єкт Promise, який буде вирішено
// або відхилено після завершення операції перейменування або переміщення.
// Вирішено без аргументів, якщо операція пройшла успішно.
// Відхилено з об'єктом помилки у випадку невдачі операції.

// import fs from 'node:fs/promises';

// // Перейменовуємо або переміщуємо файл чи каталог зі шляху 'oldfile.txt' до 'newfile.txt'

// (async () => {
//   try {
//     await fs.rename('oldfile.txt', 'newfile.txt');
//     console.log('Файл або каталог успішно перейменовано або переміщено.');
//   } catch (err) {
//     console.error('Помилка перейменування або переміщення:', err);
//   }
// })();

// --------------------------------

// [fs.unlink(path)](<https://nodejs.org/api/fs.html#fspromisesunlinkpath>) - видалення файлу.

// Цей метод використовується для асинхронного видалення файлу.

// Аргументи:

// 1. path (string): шлях до файлу, який потрібно видалити.

// Результати:

// 1. Promise: повертається об'єкт Promise, який буде вирішено
// або відхилено після завершення операції видалення.
// - Вирішено без аргументів, якщо операція видалення пройшла успішно.
// - Відхилено з об'єктом помилки у випадку невдачі операції.

// import fs from 'node:fs/promises';

// // Видаляємо файл за шляхом 'file.txt'
// (async () => {
//   try {
//     await fs.unlink('file.txt');
//     console.log('Файл успішно видалено.');
//   } catch (err) {
//     console.error('Помилка видалення файлу:', err);
//   }
// })();

// ----------------------------------------

// [fs.readdir(path)](<https://nodejs.org/api/fs.html#fspromisesreaddirpath-options>) - виведення вмісту папки

// Цей метод використовується для асинхронного отримання
// списку файлів та каталогів у заданому каталозі.

// Аргументи:

// 1. path (string): шлях до каталогу, з якого потрібно отримати список файлів і каталогів.

// Результати:

// 1. Promise: Повертається об'єкт Promise, який буде вирішено
// або відхилено після завершення операції отримання списку файлів і каталогів.
// - Вирішено з масивом рядків, який містить імена файлів і каталогів у заданому каталозі.
// - Відхилено з об'єктом помилки у випадку невдачі операції.

// import fs from 'node:fs/promises';

// // Отримуємо список файлів і каталогів у поточному каталозі
// (async () => {
//   try {
//     const files = await fs.readdir('.');
//     console.log('Список файлів і каталогів:', files);
//   } catch (err) {
//     console.error('Помилка отримання списку файлів і каталогів:', err);
//   }
// })();

// ------------------------------------------

// [fs.access(path [, mode])](<https://nodejs.org/api/fs.html#fspromisesaccesspath-mode>) - перевірка доступу до ресурсу

// Можна також перевіряти наявність папок за допомогою цього
// методу (буде використовуватися далі в курсі)

// Аргументи:

// 1. path (string): шлях до файлу або каталогу,
// доступність якого потрібно перевірити.
// 2. mode (integer або константа) (опціонально):
// режим доступу, який потрібно перевірити. Це може
// бути комбінація констант fs.constants.F_OK,
// fs.constants.R_OK, fs.constants.W_OK, fs.constants.X_OK,
// які вказують на існування, читання, запис або виконання файлу.

// Результати:

// 1. Promise: Повертається об'єкт Promise, який буде вирішено
// або відхилено після завершення операції перевірки доступності.
// - Вирішено без аргументів, якщо операція перевірки доступності
// пройшла успішно. Це означає, що файл або каталог існує та
// відповідає вказаним режимам доступу.
// - Відхилено з об'єктом помилки у випадку невдачі операції.
// Помилка може вказувати на те, що файл або каталог не існує,
// або на відсутність необхідних прав доступу.

// import fs from 'node:fs/promises';

// // Перевіряємо доступність файлу або каталогу за вказаним шляхом

// (async () => {
//   const path = 'file.txt';
//   try {
//     await fs.access(path);
//     console.log(`Файл або каталог '${path}' доступний.`);
//   } catch (err) {
//     if (err.code === 'ENOENT') {
//       console.log(`Файл або каталог '${path}' не існує.`);
//     } else {
//       console.error(
//         `Помилка перевірки доступності файлу або каталогу '${path}':`,
//         err,
//       );
//     }
//   }
// })();
